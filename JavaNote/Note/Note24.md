<span style="font-size:133%">

# 다형성
어떤 객체의 속성이나 기능이 상황에 따라 여러 다른 형태 또는 타입으로 변할 수 있는 성질이다. 

# 1. 다형적 변수
코드예제-com.eomcs.oop.ex06.a 
###
- 레퍼런스는 같은 타입의 객체를 가리킬 수 있을 뿐만 아니라 그 클래스의 서브클래스 객체까지 가리킬 수 있다. 
- 상위 클래스의 레퍼런스로 하위 클래스의 인스턴스를 가리킬 수 있다.
- 반대로 하위 클래스의 레퍼런스로 상위 클래스의 인스턴스를 가리킬 수 없다.
- 물론 다른 클래스의 인스턴스는 가리킬 수 없다. 
- 상위 클래스의 레퍼런스로 하위 클래스의 인스턴스를 가리킬 땐 타입 범위를 벗어나서 사용할 수 없다. 
- 비록 레퍼런스가 Bike 인스턴스를 가리킨다 하더라도 형식상으로는 Vehicle의 레퍼런스 이기 때문에 접근할 수 있는 범위는 Vehicle에 정의된 또는 상위클래스에 정의된 필드와 메서드만 가능하다. 
```  
vehicle.engine = true; // 컴파일 에러
```

# 2. 오버로딩(Overloading)
코드예제-com.eomcs.oop.ex06.b 
: 파라미터의 형식(타입과 개수)은 다르지만 같은 기능을 수행하는 메서드에 대해 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위한 문법이다.  

- 같은 이름의 메서드를 중복해서 만들 수 없다면 같은 작업을 수행하는 메서드라도 유사하지만 다른 이름으로 만들어야 한다.
=> 이는 일관성이 떨어지고 

- 자바에서는 타입이나 파라미터가 다르더라도 같은 일을 하는 메서드에 대해서 같은 메서드명을 갖게 할 수 있다.
- 아규먼트의 타입이나 개수에 따라 호출하는 메서드가 결정된다.
- 예시로 println(), Integer.valueOf()도 오버로딩을 사용한 메서드들이다.

# 3. 오버라이딩(Overriding)
- 상속받은 메서드를 서브클래스의 역할에 맞게 재정의하는 문법
- 사용법
  - 상속받은 메서드와 똑같은 시그니처로 메서드를 정의한다.
  - 오버라이딩 메서드는 원래의 메서드보다 접근범위가 같거나 커야 한다. 원래의 메서드보다 접근범위가 줄어들면 안된다.

### 3.1 필드 오버라이딩
- 메서드 오버라이딩과 달리 수퍼클래스의 필드를 감춰버린다. 즉 오버라이딩 되면 메서드가 소속된 클래스의 필드부터 찾기 때문에 수퍼클래스나 서브클래스 둘 중 하나의 변수 타입을 사용할 수 없다. 
- 따라서 웬만하면 사용하지 않는다. 

## 3.2 오버라이딩 실수 방지
- 자바 개발자들이 오버라이딩한다는 것을 실수로 파라미터의 형태를 달리해서 오버로딩하는 경우가 많다.
- 이에 대한 해결방법으로 @Override 애노테이션을 사용해서 컴파일러에게 검사를 받을 수 있다.

## 3.3 오버라이딩 접근 범위
- 오버라이딩 메서드의 접근 범위 유지/확대는 가능하다 원래 접근범위보다 좁힐 수는 없다.

### 상속과 super & this reference 
this: 메서드 호출 시 'this 변수에 실제 저장된 인스턴스의 클래스'부터 찾아 올라간다.
super: 메서드 호출 시 '메서드가 소속된 클래스'의 수퍼클래스부터 찾아올라간다.









</span>